package usecase

import (
	"bufio"
	"fmt"
	"maps"
	"os"
	"path/filepath"
	"regexp"
	"slices"
	"strings"

	"github.com/ettle/strcase"
)

func PrismaToSQLTables(
	schemaPath, outDir string,
) (string, error) {
	outputFilePath := filepath.Join(outDir, "table_gen.go")

	// Extract table names and columns
	tables, err := extractTableNames(schemaPath)
	if err != nil {
		return "", err
	}

	columns, err := extractColumnNames(schemaPath, tables)
	if err != nil {
		return "", err
	}

	packageName := filepath.Base(outDir)

	// Generate the Go file content
	goFileContent := generateGoFileContent(packageName, tables, columns)

	// Write the content to the output Go file
	if err := writeToFile(outDir, outputFilePath, goFileContent); err != nil {
		return "", err
	}

	if err := formatGoFile(outputFilePath); err != nil {
		return "", err
	}

	return outputFilePath, nil
}

func extractTableNames(
	filePath string,
) (map[string]string, error) {
	file, err := os.Open(filePath)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	tables := make(map[string]string) // modelName -> tableName

	modelRegex := regexp.MustCompile(`^model\s+(\w+)`)
	mapRegex := regexp.MustCompile(`@@map\("([^"]+)"\)`)

	var currentModel string
	inModelBlock := false

	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())

		// Detect new model
		if matches := modelRegex.FindStringSubmatch(line); len(matches) > 1 {
			currentModel = matches[1]
			inModelBlock = true
			tables[currentModel] = strings.ToLower(currentModel)
			continue
		}

		// Parse model fields for column names and types
		if inModelBlock {
			// Parse @@map for table name
			if matches := mapRegex.FindStringSubmatch(line); len(matches) > 1 {
				tables[currentModel] = matches[1]
			}

			// Detect end of model block
			if strings.HasPrefix(line, "}") {
				inModelBlock = false
				currentModel = ""
			}
		}
	}

	return tables, nil
}

func extractColumnNames(
	filePath string,
	tables map[string]string,
) (map[string]map[string]string, error) {
	file, err := os.Open(filePath)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	columns := map[string]map[string]string{} // modelName -> {tableName.columnName: columnType}

	modelRegex := regexp.MustCompile(`^model\s+(\w+)`)
	fieldRegex := regexp.MustCompile(
		`^(\w+)\s+(\w+)`,
	) // Matches columnName columnType

	var currentModel string
	inModelBlock := false

	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())

		// Detect new model
		if matches := modelRegex.FindStringSubmatch(line); len(matches) > 1 {
			currentModel = matches[1]
			inModelBlock = true
			columns[currentModel] = map[string]string{} // Initialize column map
			continue
		}

		// Parse model fields for column names and types
		if inModelBlock {
			if matches := fieldRegex.FindStringSubmatch(line); len(
				matches,
			) > 2 {
				columnName := matches[1]
				columnType := matches[2]
				table := tables[currentModel]

				// Only add to columns if the column type is in typeMap
				if _, exists := typeMap[columnType]; exists {
					columns[currentModel][table+"."+columnName] = columnType
				}
			}

			// Detect end of model block
			if strings.HasPrefix(line, "}") {
				inModelBlock = false
				currentModel = ""
			}
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return columns, nil
}

// generateGoFileContent generates the content of the Go file
func generateGoFileContent(
	packageName string,
	tables map[string]string,
	columns map[string]map[string]string,
) string {
	var builder strings.Builder

	// Package declaration
	builder.WriteString(
		"// Code generated by prisma-go-tools. DO NOT EDIT.\n\n",
	)
	builder.WriteString(fmt.Sprintf("package %s\n\n", packageName))
	builder.WriteString("import \"fmt\"\n\n")

	// Iterate through each table and generate its type and methods
	sortedModelNames := make([]string, 0, len(tables))
	for modelName := range tables {
		sortedModelNames = append(sortedModelNames, modelName)
	}
	slices.Sort(sortedModelNames)

	for _, modelName := range sortedModelNames {
		tableName := tables[modelName]

		// Generate type for each table
		builder.WriteString(fmt.Sprintf("type table%s string\n\n", modelName))

		builder.WriteString(
			fmt.Sprintf("func (t table%s) All() string {\n", modelName),
		)
		builder.WriteString("\treturn fmt.Sprintf(\"%s.*\", t)\n")
		builder.WriteString("}\n\n")

		// Generate column methods for each table
		cols := columns[modelName]
		fullColNames := slices.Collect(maps.Keys(cols))
		slices.Sort(fullColNames)

		for _, fullColName := range fullColNames {
			colName := strings.Split(fullColName, ".")[1]
			methodName := strcase.ToGoPascal(colName)

			// Generate method for each column in the table
			builder.WriteString(
				fmt.Sprintf(
					"func (t table%s) %s() string {\n",
					modelName,
					methodName,
				),
			)
			builder.WriteString(
				fmt.Sprintf("\treturn fmt.Sprintf(\"%%s.%s\", t)\n", colName),
			)
			builder.WriteString("}\n\n")
		}

		builder.WriteString(
			fmt.Sprintf(
				"const %s = table%s(\"%s\")\n\n",
				modelName,
				modelName,
				tableName,
			),
		)
	}

	return builder.String()
}
